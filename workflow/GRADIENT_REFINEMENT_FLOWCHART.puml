@startuml GRADIENT_REFINEMENT_Flowchart
title Gradient-Based Refinement - Detailed Decision Flowchart

start
:START;
:INPUT: current_assignment, uavs, V_matrix;
:OUTPUT: (new_assignment, improved);

:Cache: current_max_time = calculate_system_completion_time();
:Initialize: best_move = None;
:Initialize: best_time_change = 0.0;

:Loop through all source_uavs;

if (More source_uavs?) then (yes)
  :source_path = assignment[source_uav.id];
  
  if (source_path is empty?) then (yes)
    :Continue to next source_uav;
    note right
      Skip empty paths
    end note
  else (no)
  endif
  
  :Loop through all regions in source_path;
  
  if (More regions in source_path?) then (yes)
    :Loop through all target_uavs;
    
    if (More target_uavs?) then (yes)
      if (target_uav == source_uav?) then (yes)
        :Skip this target_uav;
        note right
          Avoid self-moves
        end note
      else (no)
        :time_change = estimate_time_change(region, source_uav, target_uav);
        
        if (time_change < best_time_change?) then (yes, better improvement)
          :best_time_change = time_change;
          :best_move = (region.id, source_id, target_id);
          
          if (quick_mode AND time_change < -0.5?) then (yes)
            :Break target_uav loop;
            note right
              Early termination in quick mode
            end note
          else (no)
          endif
        else (no, worse or equal)
        endif
      endif
    else (no)
      :Go to next region loop;
    endif
  else (no)
    :Go to next source_uav;
  endif
  
  if (quick_mode AND best_move exists AND good improvement?) then (yes)
    :Break source_uav loop;
  else (no)
  endif
else (no)
  :Proceed to evaluation;
endif

:All moves evaluated;

if (best_move == None?) then (yes, no move found)
  :Log: "No feasible move";
  :RETURN: (current_assignment, False);
  stop
else (no, best move found)
endif

if (verbose?) then (yes)
  :region_id, source_id, target_id = best_move;
  :Log best_move info;
  :Log "Time change: " + best_time_change;
else (no)
endif

if (best_time_change < -1e-6?) then (yes, significant improvement)
  :Extract move components;
  
  :Find region_to_move object in source_path;
  if (region_to_move == None?) then (yes)
    :Log error: Region not found;
    :RETURN: (current_assignment, False);
    stop
  else (no)
  endif
  
  :Create new_assignment (deep copy);
  
  :Remove region_to_move from source path;
  
  if (len(source_path) > 1 AND use_quick_optimization?) then (yes)
    :optimized_path = quick_path_optimization_nearest_neighbor();
    :source_path = optimized_path;
    note right
      Reorder remaining regions
      using nearest neighbor
    end note
  else (no)
  endif
  
  :Update source_path in new_assignment;
  
  :Find target_uav object;
  
  :best_pos, _ = find_best_insertion_position(region_to_move, target_path);
  
  :Insert region_to_move at best_pos in target_path;
  
  :Update target_path in new_assignment;
  
  if (verbose?) then (yes)
    :Log "Move applied!";
    :Log "Improvement: " + (-best_time_change);
  else (no)
  endif
  
  :RETURN: (new_assignment, True);
  stop
else (no, no significant improvement)
  if (verbose?) then (yes)
    :Log "No improvement, keep assignment";
  else (no)
  endif
  
  :RETURN: (current_assignment, False);
  stop
endif

:END;
end

legend left
  **Sensitivity Thresholds:**
  - best_time_change < 0: Improvement
  - best_time_change < -1e-6: Significant (avoid floating-point noise)
  - quick_mode: time_change < -0.5 for early stop
  
  **Path Operations:**
  - remove(region): O(n)
  - find_best_insertion_position: O(m*path_len) where m=UAV count
  - quick_path_optimization: O(nÂ²) nearest neighbor
  
  **Complexity:**
  - Overall: O(regions * uavs * system_eval_cost)
  - system_eval_cost = O(uavs * path_len) for time calculation
endlegend

@enduml
